{
    "contents" : "#' Scores requested subscales from a given set of lists of data frames.\n#'\n#' @param filenames A list of Excel files that contain named spreadsheets.\n#' @param subscales A character vector of the names of subscales that the user wants to compute, written so the names match those in the lookup list.\n#' @param lookupList A list object that contains scoring \"instructions\" for each subscale.\n#' @param idxOfSubj The column index in the spreadsheets that contains subject IDs. Default is 1.\n#' @param myStartRow The row index in the spreadsheets containing the variable names (i.e., headings). Defaults to row 3 because that's what I need for this project!\n#' @param writeToExcel A logical vector of length one that specifies whether the resulting data frame should be written to a new Excel file. Default is FALSE. The file will be created in the current working directory and named with occassion and subscale names and the word \"scored.\"\n#' @param path The desired location at which to save the file. Default is the working directory.\n#' @param meanSub Should item means be substituted before calculating the total? Default is FALSE.\n#' @param criterion A number indicating the maximum percent of items a subject can have missing in order to use mean substitution. Default is 50, but a warning is produced if the value is over 20 because there are more robust ways to deal with missing values than mean substitution!\n#' @return A data frame containing the requested subscale scores for each subject and occasion. That is, each subject gets a row, and each subscale-occasion combo gets its own column.\n#' @export\n\nmegaScorer <- function(filenames, subscales, lookupList, idxOfSubj = 1, myStartRow = 3, writeToExcel = FALSE, path = getwd(), meanSub = FALSE, criterion = 50){\n  occasions <- filenames\n\n  #strips off the .xlsx extension to create a vector of measurement occasion names\n  occasionNames <- sub(\".xlsx\", \"\", filenames)\n\n  #creates a one-column data frame with just subject names ... it's not \"big\" yet but it will be!\n  bigDf <- XLConnect::readWorksheetFromFile(filenames[1], sheet = 1, startRow = myStartRow)[idxOfSubj]\n  #gets the character name of the subject column just in case it's something other than \"Subjects\"\n  subjChar <- names(bigDf)\n\n    #loops through each of the occassions requested ...\n  for (occ in 1:length(occasions)){\n    #reads in the workbook as a \"workbook\" object\n    wb <- XLConnect::loadWorkbook(filenames[occ])\n    #creates a character vector of all sheet names within the workbook\n    sheetNames <- XLConnect::getSheets(wb)\n    #creates a character vector of the sheet names that do NOT contain the word \"check\"\n    sheetNames <- grep(\"check\", sheetNames, ignore.case = T, value = T, invert = T)\n\n    #tell the user what occasion is being scored\n    cat(\"==== Now scoring \", occasionNames[occ], \" ====\\n\", sep = \"\")\n\n    #then, for each subscale, scores it as follows.\n    for (subsc in 1:length(subscales)){\n\n      #gets the appropriate measure names and scoring information from the lookup table\n      measName <- lookupList[[subscales[subsc]]]$measName\n      forwItems <- lookupList[[subscales[subsc]]]$forwItems\n      revItems <- lookupList[[subscales[subsc]]]$revItems\n      revInt <- lookupList[[subscales[subsc]]]$revInt\n\n      #creates a vector of indices of the workbook sheets in the current occasion that match the measure needed for the current subscale\n      measIdx <- grep(measName, sheetNames, ignore.case = T)\n\n      #if no sheets match, tells the user that the measure was not collected at the time point\n      if(length(measIdx) == 0){\n        cat(\"The\", subscales[subsc], \"was not assessed for\", occasionNames[occ], \"\\n\")\n\n        #if there is more than one sheet that matches the measure name, warns the user that there might be an error and does not score the measure\n      }else if (length(measIdx) > 1){\n        warning(paste(\"There are\", length(measIdx), \"sheets that match\", measName, \"at\", occasionNames[occ], \", so this measure at this occasion will not be scored.\\n\"))\n\n        #if there is one and only one sheet that matches the measure name, scores that subscale\n      }else if (length(measIdx) == 1){\n\n        #tells the user which subscale is being scored\n        cat(\"Scoring\", occasionNames[occ], subscales[subsc], \"\\n\")\n\n        #read in the necessary sheet to a data frame\n        measDf <- XLConnect::readWorksheet(wb, sheet = measName, startRow = myStartRow)\n        #if mean substitution requested, replaces the data frame with one in which item means are substituted for missing values (for those subjects that meet the missingness criterion)\n        if (meanSub){\n          measDf <- meanSubstitute(measDf, forwItems = forwItems, revItems = revItems, revInt = revInt, criterion = criterion)\n        }\n\n        #creates a two-column data frame with the subject IDs and the total scores\n        littleDf <- calcSubscale(measDf, forwItems = forwItems, revItems = revItems, revInt = revInt)\n        #names the column containing the total score with the name of the subscale and the occasion\n        colnames(littleDf)[2] <- paste(occasionNames[occ], subscales[subsc], sep = \"_\")\n  \n        #merges the new data frame with the previous data frame, by whatever name is given to subjects in these data sets (in my data sets it's just \"Subject\")\n        bigDf <- merge(bigDf, littleDf, by = subjChar, all = T, sort = F, suffixes = c(\"\", occasionNames[occ]))\n      }\n    }\n\n    #once all of the subscales have been looped-over, removes the workbook to free up memory (I hope!)\n    rm(wb)\n  }\n\n  if(writeToExcel == T){\n    #pastes together the names of the occassions and then the subscales in order, separated by underscores; if mean sub requested, also includes the word MEANSUB and the criterion value\n    if (meanSub){\n      filename <- paste(paste(occasionNames, collapse = \"_\"), \"_\", paste(subscales, collapse = \"_\"), \"_SCORED_MEANSUB\", criterion, \".xlsx\", sep = \"\")\n    }else{\n          filename <- paste(paste(occasionNames, collapse = \"_\"), \"_\", paste(subscales, collapse = \"_\"), \"_SCORED.xlsx\", sep = \"\")\n    }\n\n    #pastes together the filename and the specified path at which to store the file; default is working directory\n    totalpath <- paste(path, \"/\", filename, sep = \"\")\n    #writes the data frame to an Excel file at the specified location\n    XLConnect::writeWorksheetToFile(file = totalpath, data = bigDf, sheet = \"Scored\")\n  }\n\n  return(bigDf)\n}\n",
    "created" : 1433642373799.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2621683339",
    "id" : "8CE1A4DC",
    "lastKnownWriteTime" : 1433862974,
    "path" : "~/research/samcleanR/R/megaScorer.R",
    "project_path" : "R/megaScorer.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : true,
    "type" : "r_source"
}