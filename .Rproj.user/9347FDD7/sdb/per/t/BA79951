{
    "contents" : "#' Creates a data frame containing the percentage of items that are missing for a given set of subscales and measurement occasions for each subject.\n#'\n#' @param filenames A list of Excel files that contain named spreadsheets.\n#' @param subscales A character vector of the names of subscales for which the user wants to know missingness.\n#' @param lookupList A list object that contains scoring \"instructions\" for each subscale.\n#' @param idxOfSubj The column index in the data frames that contains subject IDs. Default is 1.\n#' @param myStartRow The row index in the spreadsheets containing the variable names (i.e., headings). Defaults to row 3 because that's what I need for this project!\n#' @param writeToExcel A logical vector of length one that specifies whether the resulting data frame should be written to a new Excel file. Default is FALSE. The file will be created in the current working directory and named with occassion and subscale names and the word \"scored.\"\n#' @param path The desired location at which to save the file. Default is the working directory.\n#' @return A data frame containing the percentage of values that are missing for each subject and occasion. That is, each subject gets a row, and each subscale-occasion combo gets its own column.\n#' @export\n\nmegaMissingness <- function(filenames, subscales, lookupList, idxOfSubj = 1, myStartRow = 3, writeToExcel = FALSE, path = getwd()){\n  #makes all of the lists of data frames into a list of lists of data frames (ouch!)\n  occasions <- filenames\n  #gives each list the name of the list item as passed in, and also assigns this character vector to occasionNames\n  occasionNames <- sub(\".xlsx\", \"\", filenames)\n\n  #creates a one-column data frame with just subject names ...\n  missingDf <- XLConnect::readWorksheetFromFile(filenames[1], sheet = 1, startRow = myStartRow)[idxOfSubj]\n  #gets the character name of the subject column just in case it's something other than \"Subjects\"!\n  subjChar <- names(missingDf)\n\n  #loops through each of the subscales requested ...\n  for (occ in 1:length(occasions)){\n#     wb <- XLConnect::loadWorkbook(filenames[occ])\n#     #creates a character vector of all sheet names within the workbook\n#     sheetNames <- XLConnect::getSheets(wb)\n#     #creates a character vector of the sheet names that do NOT contain the word \"check\"\n#     sheetNames <- grep(\"check\", sheetNames, ignore.case = T, value = T, invert = T)\n\n    wb <- XLConnect::loadWorkbook(filenames[occ])\n    #creates a character vector of all sheet names within the workbook\n    sheetNames <- XLConnect::getSheets(wb)\n    #creates a character vector of the sheet names that do NOT contain the word \"check\"\n    sheetNames <- grep(\"check\", sheetNames, ignore.case = T, value = T, invert = T)\n\n        #tells the user which subscale is being checked\n    cat(\"==== Now checking\", occasionNames[occ], \" ====\\n\", sep = \"\")\n\n    #then, for each occasion, calculates missingness for that subscale as follows.\n    for (subsc in 1:length(subscales)){\n      #... and gets the appropriate measure name and scoring information from the lookup table\n      measName <- lookupList[[subscales[subsc]]]$measName\n      forwItems <- lookupList[[subscales[subsc]]]$forwItems\n      revItems <- lookupList[[subscales[subsc]]]$revItems\n\n      #creates a character vector containing all items that are used to score the subscale (regardless of forward or reverse); removes NAs if they somehow ended up on there\n      allitems <- na.omit(c(forwItems, revItems))\n\n      #creates a vector of indices of the sheets in the current occasion that match the measure needed for the current subscale\n      measIdx <- grep(measName, sheetNames, ignore.case = T)\n\n      #if no sheets match, tells the user that the measure was not collected at the time point\n      if(length(measIdx) == 0){\n        cat(\"The\", measName, \"was not collected at\", occasionNames[occ], \"\\n\")\n\n        #if there is more than one sheet that matches the measure name, warns the user that there might be an error and does not score the measure\n      }else if (length(measIdx) > 1){\n        warning(paste(\"There are\", length(measIdx), \"sheets that match\", measName, \"at\", occasionNames[occ], \", so missingness at this occasion will not be computed.\\n\"))\n\n        #if there is one and only one sheet that matches the measure name, scores that subscale\n      }else if (length(measIdx) == 1){\n\n        #tells the user what occasion is being computed\n        cat(\"Computing missingness at\", occasionNames[occ], \"for\", subscales[subsc], \"\\n\")\n\n        #read in the necessary sheet to a data frame\n        measDf <- XLConnect::readWorksheet(wb, sheet = measName, startRow = myStartRow)\n\n        #creates a two-column data frame with the subject IDs and the missing percentages\n        littleDf <- calcPercentMissing(measDf, items = allitems)\n        #names the column containing the percent with the name of the subscale and the occasion\n        colnames(littleDf)[2] <- paste(occasionNames[occ], subscales[subsc], sep = \"_\")\n        #merges the new data frame with the previous data frame, by whatever name is given to subjects in these data sets (in my data sets it's just \"Subject\")\n        missingDf <- merge(missingDf, littleDf, by = subjChar, all = T, sort = F, suffixes = c(\"\", occasionNames[occ]))\n      }\n    }\n\n    #once all of the subscales have been looped-over, removes the workbook to free up memory (I hope!)\n    rm(wb)\n  }\n\n  if(writeToExcel == T){\n    #pastes together the names of the occassions and then the subscales in order, separated by underscores\n    filename <- paste(paste(occasionNames, collapse = \"_\"), \"_\", paste(subscales, collapse = \"_\"), \"_MISSINGNESS.xlsx\", sep = \"\")\n    #pastes together the filename and the specified path at which to store the file; default is working directory\n    totalpath <- paste(path, \"/\", filename, sep = \"\")\n    #writes the data frame to an Excel file at the specified location\n    XLConnect::writeWorksheetToFile(file = totalpath, data = missingDf, sheet = \"Missing\")\n  }\n\n  return(missingDf)\n}\n\n\n\n\n\n",
    "created" : 1433720129471.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1543277437",
    "id" : "BA79951",
    "lastKnownWriteTime" : 1433858894,
    "path" : "~/research/samcleanR/R/megaMissingness.R",
    "project_path" : "R/megaMissingness.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : true,
    "type" : "r_source"
}