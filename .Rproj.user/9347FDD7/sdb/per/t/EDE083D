{
    "contents" : "#' Scores requested subscales from a given set of lists of data frames.\n#'\n#' @param ... One or more lists that contain named data frames as their elements. Each list in my data set corresponds to a measurement occasion.\n#' @param subscales A character vector of the names of subscales that the user wants to compute, written so the names match those in the lookup list.\n#' @param lookupList A list object that contains scoring \"instructions\" for each subscale.\n#' @param idxOfSubj The column index in the data frames that contains subject IDs. Default is 1.\n#' @param writeToExcel A logical vector of length one that specifies whether the resulting data frame should be written to a new Excel file. Default is FALSE. The file will be created in the current working directory and named with occassion and subscale names and the word \"scored.\"\n#' @param path The desired location at which to save the file. Default is the working directory.\n#' @return A data frame containing the requested subscale scores for each subject and occasion. That is, each subject gets a row, and each subscale-occasion combo gets its own column.\n#' @export\n\nmegaScorer <- function(..., subscales, lookupList, idxOfSubj = 1, writeToExcel = FALSE, path = getwd()){\n  #makes all of the lists of data frames into a list of lists of data frames (ouch!)\n  occasions <- list(...)\n  #gives each list the name of the list item as passed in, and also assigns this character vector to occasionNames\n  occasionNames <- names(occasions) <- as.character(substitute(list(...)))[-1L]\n\n  #creates a one-column data frame with just subject names ... it's not \"big\" yet but it will be!\n  bigDf <- occasions[[1]][[1]][idxOfSubj]\n  #gets the character name of the subject column just in case it's something other than \"Subjects\"\n  subjChar <- names(bigDf)\n\n  #loops through each of the subscales requested ...\n  for (subsc in 1:length(subscales)){\n\n    #... and gets the appropriate measure names and scoring information from the lookup table\n    measName <- lookupList[[subscales[subsc]]]$measName\n    forwNames <- lookupList[[subscales[subsc]]]$forwNames\n    revNames <- lookupList[[subscales[subsc]]]$revNames\n    revInt <- lookupList[[subscales[subsc]]]$revInt\n    #tells the user which subscale is being scored\n    cat(\"==== Now scoring \", subscales[subsc], \" ====\\n\", sep = \"\")\n\n    #then, for each occasion, scores that subscale as follows.\n    for (occ in 1:length(occasions)){\n      #creates a vector of indices of the data frames in the current   occasion that match the measure needed for the current subscale\n      measIdx <- grep(measName, names(occasions[[occ]]), ignore.case = T)\n\n      if(length(measIdx) == 0){\n\n        #if no data frames match, tells the user that the measure was not collected at the time point\n        cat(\"The\", measName, \"was not collected at\", occasionNames[occ], \"\\n\")\n      }else if (length(measIdx) > 1){\n\n        #if there is more than one data frame that matches the measure name, warns the user that there might be an error and does not score the measure\n        warning(paste(\"There are\", length(measIdx), \"sheets that match\", measName, \"at\", occasionNames[occ], \", so this measure at this occasion will not be scored.\\n\"))\n      }else if (length(measIdx) == 1){\n        #tell the user what occasion is being scored\n        cat(\"Scoring\", occasionNames[occ], subscales[subsc], \"\\n\")\n\n        #creates a two-column data frame with the subject IDs and the total scores\n        littleDf <- calcSubscale(occasions[[occ]][[measIdx]], forwNames = forwNames, revNames = revNames, revInt = revInt)\n        #names the column containing the total score with the name of the subscale and the occasion\n        colnames(littleDf)[2] <- paste(occasionNames[occ], subscales[subsc], sep = \"_\")\n        #merges the new data frame with the previous data frame, by whatever name is given to subjects in these data sets (in my data sets it's just \"Subject\")\n        bigDf <- merge(bigDf, littleDf, by = subjChar, all = T, sort = F, suffixes = c(\"\", occasionNames[occ]))\n      }\n    }\n  }\n\n  if(writeToExcel == T){\n    #pastes together the names of the occassions and then the subscales in order, separated by underscores\n    filename <- paste(paste(occasionNames, collapse = \"_\"), \"_\", paste(subscales, collapse = \"_\"), \"_SCORED.xlsx\", sep = \"\")\n    #pastes together the filename and the specified path at which to store the file; default is working directory\n    totalpath <- paste(path, \"/\", filename, sep = \"\")\n    #writes the data frame to an Excel file at the specified location\n    xlsx::write.xlsx(bigDf, file = totalpath, sheetName = \"Scored\", row.names = F, showNA = F)\n  }\n\n  return(bigDf)\n}\n",
    "created" : 1433532419003.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2511182206",
    "id" : "EDE083D",
    "lastKnownWriteTime" : 1433612815,
    "path" : "~/research/samcleanR/R/megaScorer.R",
    "project_path" : "R/megaScorer.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}